## LL(1)

我们手里只有按顺序的token集合，也就是语法树的叶节点集合，对于如何把token序列还原成一棵树，我们首先考虑一下如何表示这颗树


```java
class 函数{
    类型 返回值;
    语句 函数体[];
    String 函数名;
    {类型,名字} 参数列表[];
    函数(){
        Token token;
        token=下个token();
        if(token[0]==类型)
            返回值=token;
        else
            报错();
        //类似的错误处理下面类似，为方便，不进行错误处理
        函数名=读标识符();
        读左括号();
        参数列表=读参数列表();
        读右括号();
        ....
    }
}
```

这是一个非叶节点的例子，好像获得一个非叶节点不是很难，就是递归的不断向下展开非叶节点，难点在于有的时候展开的方法不唯一，例子

  表达式 -> 加法表达式|乘法表达式|除法表达式|...

```
TODO:这里可能还是加张图比较清晰
```

如何知道在这种情况下展开成哪种树，是主要问题

LL(1)方法是看当前要读取的下一个token，在展开的树类型中，只有一种的开头token可以是这个，那就选择展开成这种子树，如果不止一种，则是LL(1)能力所限，问题无法用LL(1)方法解决

于是需要计算出所有非叶节点的可能的开始token,称作`FIRST集`

有些规则可以推导出空，对于这种情况则其后面的规则也需要被考虑，所以计算所有规则中跟在这个规则后面出现的符号，称作`FOLLOW集`


例题(算术表达式)

$$E -> T + E'$$
$$E -> T - E'$$
$$T -> a$$
$$E' -> + T E'$$
$$      - T E'$$
$$      \epsilon$$

FIRST(T)=a
