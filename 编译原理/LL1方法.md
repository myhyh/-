# 暴力展开回溯法
我们有展开规则和有顺序的token列表,如何得到语法树?

最开始我们只有树的根节点,其展开规则不唯一,选择哪条规则都不妥当,先选一条展开试试,如果失败,退回来换第二条,以此类推,这方法的时间代价是指数级的,稍大一些的程序就受不了了

# LL(1)
对于不同的展开规则,如果它能接受的第一个token总是不同的(token集合总是不相交的),那么只需要查看当前手里剩余的第一个token,即可决定选用哪一条展开规则,无需回溯,符合这个条件的规则称为LL(1)的

所以需要算出所有规则的第一个可能的token(集合),称作first集合

规则集合实质上也是一棵树,其叶节点是token本身,我们就从token这一层逐渐往上算first集合

token的first集合是其自身,再往上一层的开头肯定是某个token,再往上一层的开头肯定是这层的某个规则,以此类推,算出所有的规则开头,问题就解决了

## 空规则
存在规则推出空的情况,我们无法像NFA转DFA时那样消除所有的空规则,因为词法自动机中,中间节点是没有意义的,而语法中,即使是空规则推出的句子也是很可能有意义的,不能随随便便扔掉.

一种方法是当其他规则都不匹配的时候使用空规则,但是这样可能匹配了大量的空规则之后发现下一个token是错的,根本对不上任何一个规则,如何利用我们已知的第一个token,尽可能的早报告语法错误呢?

如果当前规则推出空,则手里的第一个token是紧接着这个规则的下一个规则的开头token,所以只要知道可能紧接在当前规则后面的规则的开头token都可能有哪些即可判断下一个token是否合法,称作当前规则的follow集合

```
实际上follow集合除了早报错以外毫无作用,徒增程序的复杂性,完全等价于当其他规则都不匹配的时候使用空规则
```

和算first集合一样,自底向上的计算每个符号后面可能跟着的符号集合

最终我们利用follow集合来增强first集合,得到first+集合,如果一个规则推出的第一个子规则可以推出空,那么它第一个子规则的follow集合应当加入其first集合

接下来的事情就简单了,利用状态转换规则构建程序即可

## LL(k)方法
不只看一个符号,而是看k个,这样对语法的限制就放宽了