# 第一章
算法的设计 

出发点:问题,输入,输出

要点:正确,高效,易于实现

1.1

算法(algorithms):永远取得正确的结果
启发式(heuristics):能取得不错的结果,但是不保证正确

1.2
```
算法的正确性必须严格证明,人的思维是不可靠的,看起来合理的算法可能根本不正确
```
1.3 考量算法的正确性

清晰,准确的描述要证明的东西

拿出一系列问题的假设作为前提

1.3.1 描述算法

层次从高到低
- 人类语言
- 伪代码
- 真实代码

人类语言易于理解,但不精确,真实代码精确,但不易理解
```
个人认为是人类语言更结构化,描述性,而真实代码更线性化,顺序性的原因
```

描述的最终目的是为了清晰,不要为了使它看起来严谨,就使用伪代码,可能还不如人类语言清晰
```
算法的核心是思想(idea),如果算法的描述不能显示出其思想,那么可能是描述层次太低,太过细节导致的
```
1.3.2 描述问题的属性

- 允许的输入
- 输出的要求

这两点都必须准确表述,模糊的表述无法证明

很多时候问题的描述过于宽泛,允许的输入种类太多
```
寻找算法的有效方法: 缩小输入允许的范围,降低其复杂性,直到寻找到一个高效的算法,比如输入是图,那么假定它是树;输入是三维图形,试着在二维上解决问题
```

对输出的要求常见的错误是定义不明确,要求输出最好的结果,就得定义清楚什么是最好

另一个常见错误是过于复杂的输出要求,导致问题根本无法下手,也无法简单的证明算法的正确性

研究经典问题的问题定义,可以为自己发现的新问题写定义做参考

1.3.3 演示不正确性

通过举反例推翻一个算法

一个好的反例有两个特点
- 易于验证(Verifiability):带进去一跑,出个结果,然后能显而易见的找到一个更好的结果,明显没找着
- 易于理解(Simplicity):反例的结构简单,能明显揭示算法没考虑到的情况

构造好反例的要点
- 从小例子开始思考:大而混乱的例子让人茫然无措,小例子易于验证和思考
- 穷尽思考:一个问题最简单的例子不会有很多种,比如说一个数轴上的两个区间关系只有三种,相交,包含,相离,如果所有简单情况都不出问题,一般算法就不会有什么问题了
- 寻找弱点:算法里面可能有着一些描述有明显的漏洞,比如`永远取最大`这样的贪心描述,可以试着针对这些假设举反例
- 寻找平局(问题的转折点):比如`永远取最大`,那么如果所有输入一样大,取哪个呢?
- 寻找极限情况:反例中常常混杂着极大和细微,最左和最右,最多和最少,最远和最近,有极限情况的例子经常是易于思考的

```
证明算法不对,最好的方法是找反例
```

1.3.4 演绎推理和递归

问题很多情况下是递归的(recursive)或者增进的(incremental),思考这样的问题的要点
- 基本情况是正确的
- 从一个正确的情况向上走一步(进行一次规约)是正确的
- 那么所有的情况就是正确的

但是这样的证明中很多时候隐藏着错误
- 考虑基本情况的时候没考虑边界情况
- 使用了根本不存在的假设


1.4 问题建模

现实问题是具体的,而算法是解决抽象问题的,从具体问题到抽象问题的转化就是建模,合适的建模使得我们可以使用现有的算法而不必自己设计

1.4.1 对象的组合
把问题中的对象抽象成一些抽象对象

- 排列:问题中出现“arrangement,” “tour,” “ordering,” or “sequence 这些词的时候
- 组合(子集):“cluster,” “collection,” “committee,” “group,” “packaging,” or “selection.”
- 树:问题中出现明显的层次结构时,以及“hierarchy,” “dominance relationship,” “ancestor/descendant relationship,” or “taxonomy.”
- 图:一系列对象的关系网络,“network,” “circuit,” “web,” or “relationship.”
- 点:几何空间的位置,“sites,” “positions,” “data records,” or “locations.”
- 多边形:几何空间的区域,“shapes,” “regions,” “configurations,” or “boundaries.”
- 串:一类对象连续的序列,“text,” “characters,” “patterns,” or “labels.”


一些警告
- 问题建模使得我们的应用程序的适用范围减小
- 一个问题通常有多种建模方式,有些比其他的好得多

```
把问题建模到定义明确的结构上是设计算法最重要的一步
```