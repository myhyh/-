## 系统调用和库函数的区别

系统调用属于内核，库函数属于用户态。

函数库中的某些函数调用了系统调用。

函数库中的函数可以没有调用系统调用，也可以调用多个系统调用。

通过软中断 int 0x80 从用户态进入内核态。

高级编程可以直接通过 int 0x80 进入系统调用，而不必通过函数库作为中介。

### 系统调用

系统调用提供的函数如 open, close, read, write, ioctl 等，需包含头文件 `#include <unistd.h>`。

系统调用发生在内核空间，如果在用户空间的一般应用程序中使用系统调用来进行文件操作，会有用户空间到内核空间切换的开销。

事实上，即使在用户空间使用库函数来对文件进行操作，因为文件总是存在于存储介质上，因此不管是读写操作，都是对硬件（存储器）的操作，都必然会引起系统调用。

也就是说，库函数对文件的操作实际上是通过系统调用来实现的。例如 C 库函数 fwrite() 就是通过 write() 系统调用来实现的。

这样的话，使用库函数也有系统调用的开销，为什么不直接使用系统调用呢？

这是因为，读写文件通常是大量的数据（这种大量是相对于底层驱动的系统调用所实现的数据操作单位而言），使用库函数就可以大大减少系统调用的次数。

这一结果又缘于缓冲区技术。

在用户空间和内核空间，对文件操作都使用了缓冲区，例如用 fwrite 写文件，都是先将内容写到用户空间缓冲区，当用户空间缓冲区满或者写操作结束时，
才将用户缓冲区的内容写到内核缓冲区，同样的道理，当内核缓冲区满或写结束时才将内核缓冲区内容写到文件对应的硬件媒介。

### 库函数

如标准 C 库函数提供的文件操作函数如 fopen, fread, fwrite, fclose, fflush, fseek等，需包含头文件 `#include <stdio.h>`。

库函数调用通常用于应用程序中对一般文件的访问。

### 总结

* 系统调用是操作系统相关的，因此一般没有跨操作系统的可移植性

* 库函数属于语言本身一部分，与操作系统无关的，因此可移植性好
