# RPC 远程过程调用
其目的在于减小程序员的心智负担,像调用本地函数一样调用远程的代码

RPC过程:
* 传递函数名,参数
* 等待服务器计算
* 拿到返回值

## 如何传递参数
TCP等网络协议

## 机器架构的不同导致数据的表示不同
使用Thrift,JSON等格式,可以无视机器架构的不同
```
基本数据格式的网络通用表示是比较容易思考的
list在网络中可以采用 列表长度+所有列表项 来表示,也可以是 起始符+所有列表项+结束符的形式表示
map可以采用键值对,也就是list<(key,value)> 的形式传输
这也是很多框架采用的方法
对于更复杂的图结构,可以采用list<node>的形式传输,node中所有互相的索引替换成列表中的下标,不过这样复杂的实现最好交给程序员去做,以保证最大的灵活性,而不是固化在框架里,所以框架都没有提供图结构
```

## 调用失败问题
网络是不可靠的,机器也是不可靠的,调用失败问题无法解决.在一台机器上,这不是问题,因为函数就是程序的一部分,函数调用失败,程序就崩溃了.而分布式情况下,如果出了问题,客户端无法得知调用成功与否,是服务器出了故障还是网络故障也无法得知

### 失败的几种可能性
* 网络问题
  * 请求丢失
  * 响应丢失
* 机器问题
  * 发送请求后客户端挂了
  * 收到请求后,处理请求前服务端挂了
  * 处理请求后,回复请求前服务端挂了
* 上述问题的组合

### 给出几种可能的模型
* 正好一次(Exactly-once):理想情况,调用且仅调用一次函数,理论上是无法保证一定能做到的
* 至少一次(At least once):对于有幂等性的操作,可以采用这个模型
* 至多一次(At most once):函数可能被调用,也可能没有被调用,但最多被调用一次
* 0次或1次(Zero or once):类似事务的语义

### 实现方案

#### 至少一次
客户端不停的请求服务端,直到获得一次响应

优势:服务端无需任何复杂逻辑,按部就班的处理请求即可

#### 最多一次
服务端可能重复收到相同的请求,但是只执行一次

给每个请求一个id,通过`请求id+请求者身份`唯一标识每个请求,然后缓存一定id范围的计算结果,如果重复请求,返回相同的结果

这类似于TCP的滑动窗口协议,也可以学习滑动窗口协议的优化方案

#### 正好一次
没有办法实现,只能尽可能的缩短任务执行,数据传输的时间,以减少被故障命中的可能性

## 性能问题

### 数据转换为通用格式太慢
如果事先知道数据只在一种架构的机器之间传输,那就根本不用转换.如果事先知道只在几种架构间传输,可以根据其特点针对性的设计格式,尽量减少转换

### 缓冲区之间复制数据的开销
writev之类的方法可能能缓解这个问题

## 环境差异

### 磁盘访问?
如果使用read(...)这样的系统调用,如何化为远程调用呢?采用分布式文件系统是可以的.

### 内存访问?
采用一个统一的分布式地址空间可以解决,但是往往得不偿失,还不如让程序员设计一套不那么通用但是高性能的方案

## 总结
当没遇到问题的时候,隐藏实现的细节以让程序员轻松,而容易遇到问题的地方,则把调用的远程性暴露给程序员,让他们能个性化的处理失败和性能的问题

## 异步RPC
发送rpc请求之后,只要服务端收到请求并接受请求(返回ack,状态ok),就不等待服务端回复,继续进行自己的任务,等服务端发回响应时中断手上的任务,读取响应