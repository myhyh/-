# 从C转向C++

### 条款1
尽量用const和inline而不用#define

易于调试(有符号),类型安全

### 条款2
尽量用`<iostream>`而不用`<stdio.h>`,因为类型安全,不容易出错

### 条款3
尽量用new和delete而不用malloc和free,因为new和delete了解C++中的构造函数和析构函数,不会忘记初始化和销毁对象内部成员

### 条款4
尽量使用C++风格的注释,因为不存在注释嵌套问题,当然,c的老风格注释也很有用

# 内存管理

### 条款5
使用new创建的,用delete销毁

使用new []创建的,使用delete[]销毁

使用malloc申请的,使用free释放

不要搞混,不要错用

懒的话,对于数组直接用vector容器,方便

```c++
实测创建基本类型new,new[],delete,delete[]混用没问题,也没有内存泄漏,而对于对象类型,程序直接崩溃,因为对于对象类型的销毁需要调用析构函数,所以需要记录有几个对象,实际上内存分配的时候

new int[3] 是 |int|int|int|
new A[3] 是 |3|(返回的首地址)A|A|A|

delete的时候没有往回倒,删错地址导致分配器崩溃
用delete[]就没问题了
```


### 条款6
不要忘记delete对象内的指针成员

delete NULL不会报错

懒的话用智能指针

### 条款7
处理内存不足的情况(调用new操作符失败)

new操作符其实是一个全局函数,可以使用`::operator new`调用,来分配内存,但是它存在失败的可能,会抛出std::bad_alloc异常,每次都使用try,catch处理太麻烦.

在new失败时会先调用注册的new_handler函数来试图处理,不断重复直到
* 内存充足使用内存
* new_handler==NULL抛出异常


使用set_new_handler函数即可注册全局的new_handler.new_handler可以采用的策略有

* 承担工作:释放一些内存
* 转移责任:set_new_handler(另一个handler);
* 默认异常:set_new_handler(NULL);
* 自定义异常:直接抛出继承自std::bad_alloc的异常
* 彻底自杀:abort();

new_handler是全局的,希望注册类专属的new_handler则可以
- 类内放一个static变量记录自定义new_handler
- 重载operator new使得在调用当前operator new时使用自定义new_handler,用完恢复
- 这个很套路,继承Code Examples/new_handle.cpp中的NewHandlerSupport即可获得此功能,不用自己手写,这个继承全是静态成员,即使多继承也没有开销

new(nothrow) ... 这样使用new操作符在分配失败时会返回0而不抛异常

### 条款8
operator new会被子类继承,而这时分配基类的大小肯定不对,怎么办?

把工作交给全局operator new

重载operator new[]来应对对象数组分配的情况

### 条款9
类内重载的operator new会覆盖类内函数调用new时使用的operator new,需要注意

### 条款10

写了operator new就得写operator delete,因为采用的设计思路不同(比如在自己的内存池里申请内存),自定义new的内存,系统的delete很有可能释放不了

### 条款11
为需要动态分配内存的类声明一个拷贝构造函数和一个赋值操作符
因为默认仅按字节复制会只把指针复制过来(浅拷贝),内存中对应的数据没复制

### 条款12
尽量使用初始化而不要在构造函数里赋值

原因:为了性能,在构造函数里赋值相当于先默认构造一次,再调一次赋值操作符,而初始化只构造一次

### 条款13
初始化列表中成员列出的顺序和它们在类中声明的顺序相同(和初始化列表中的书写顺序无关)

```
个人理解原因:如果只在初始化列表中初始化一部分成员,编译器对于初始化顺序只能一脸懵逼,所以干脆全按声明顺序初始化,怎样都不会乱
```

### 条款14
确定基类有虚析构函数

子类对象常被基类指针引用,delete对应指针时若析构函数非虚,则只调用了基类的析构函数,会导致资源没完全释放的问题

### 条款15
让operator=返回*this的引用

为了连续应用operator=,和数值类型相一致

### 条款16
在operator=中对所有数据成员赋值

尤其不要忘了调用基类的operator=,可以采用的形式
* Base::operator=(rhs);
* static_cast<Base&>(*this)  =  rhs;
拷贝构造函数也别忘了调基类的拷贝构造

### 条款17
在operator=中检查给自己赋值的情况

因为很多情况赋值是先释放自己申请的资源,然后把对方的资源拿过来,然而如果对方就是自己,那资源已经释放了,当然拿过来的也不对了

处理方案:
* 赋值前比较内存地址
* 类内定义一个identity函数,为每个对象分配不同的id(类似java的hashCode)

# 类和函数：设计与声明

### 条款18

类的接口应当完整且最小化:
* 功能完整,一个类才有其存在的意义
* 正交原则,一个接口不应该能由其他接口的组合实现,有如下例外:
  * 能改善性能
  * 能防止用户犯低级错误,提高易用性

优点: 易于理解,易于维护,编译快

另: 友元函数也属于接口的一部分

### 条款19

什么时候用类成员函数,什么时候用非成员函数,什么时候用友元函数

* 当一个行为只用一个类作为主体的时候,采用类成员函数,例子略

* 当一个行为的主体可能是多种类型的时候,采用非成员函数,例如 `整数*有理数` 以整数为主体,`有理数*整数`以有理数为主体,这时就需要把`operator=`的实现放在类外.

* 如果放在类外却需要用到类的私有成员,就用友元函数

* 例外:当主体类由别人提供,我们无法修改的时候,采用非成员函数,例如为我们自定义的类型实现`operator<<`输出到cout,主体是cout,但是我们改不了

### 条款20

public成员都得是函数,不要放数据

因为可以修改函数的实现而外面的调用形式不变,数据就做不到了

个人补充:其他语言常见的一个语法糖property,把不需要参数的这类函数伪装成数据成员的样子

### 条款21

尽量使用const,因为不应该被写的内容编译器帮咱做保证是最方便的

const成员函数不能修改成员变量,想修改的话,对应的成员变量声明为mutable

### 条款22
函数调用尽可能传引用而不是传值

可以减少对象的复制,同时保留多态性(因为引用通过指针实现)

### 条款23
返回值则不能通过传引用来优化

### 条款24
何时使用函数参数默认值,何时使用重载

能找到一个合适的默认值,且函数的算法与参数数量无关时(有关的例子,取n个数的平均值),采用默认值,否则重载.

### 条款25
数字和指针类型不要进行重载,因为存在隐式转换,C++11的nullptr一定程度上解决了这个问题,所以尽量用nullptr而不再用NULL
nullptr的一种可能的实现见CodeExamples/mynullptr.cpp

### 条款26
c++程序可能有二义性,因为c++规定,潜在的二义性不算错误,直到实在调用发生二义,才报错

* 隐式类型转换(A->B):
    ```c++
    class A{
        operator B(){...}   //第一种
    };

    class B{
        B(A){...}   //第二种
    }
    ```

* 数值类型(double->(int,short,long,char))
* 多继承中多个基类有同名成员函数
```c++
class A{
    public:
    void x();
};

class B{
    public:
    void x();
};

class C:public A,public B{
};


C c;
c.x();  //有歧义
C.A::x();   //无歧义
```


### 条款27
如果不需要编译器默认生成的函数,禁用之

编译器自动为类生成无参构造,析构函数,拷贝构造,...,这些函数有时候我们并不需要,所以要将其放进private(防止外部调用)并不写实现(防止友元调用)

另:Rust不存在这个问题,因为Rust中的类默认不包含任何函数

### 条款28
尽量使用namespace,分开名字空间以防命名冲突,以及提高可读性

# 类和函数: 实现

### 条款29
成员函数不要返回对象内部的堆指针

破坏封装性导致无法信任对象的const性,以及无法确定这个指针的生命周期,导致可能出大bug

实在需要的话,返回一个const的指针,例如string的c_str返回const char*,防止用户修改string内容

### 条款30
不要返回对象内部私有成员及成员函数的指针

因为这样private毫无意义

### 条款31
不要返回临时对象的引用,因为对象已被销毁

不要返回new对象的引用,因为这样就把销毁的责任交给用户了,用户会忘记的

### 条款32
变量要用到时再定义,因为运行到定义的点会调构造函数,如果在函数头定义,则会增大开销

而且用到时再定义,逻辑结合更加紧密


### 条款33
谨慎使用inline


由于inline是把函数代码展开到调用点处,inline会导致代码膨胀,inline会导致每次修改函数,所有用到inline的地方都得重编译,inline函数中的static变量有问题,inline无法和virtual一起用,inline函数无法调试

所以只对短代码使用inline,并延迟到优化阶段,使用profiler去寻找合适的使用点

### 条款34

为了提高编译速度,分离接口和实现,因为改变实现代码,所有`#include`这个实现的地方都会被重编译

方法1(pimpl):把类的实现(数据,函数实现)放到另一个类Impl中,只在原类中留一个指向Impl的指针,这样类的内存大小被确定,而且成员函数的实现都是简单调用Impl的同名函数,不再变化,不再被重编译

方法2:使用抽象类(含纯虚函数)作为基类,程序中只使用基类的指针,而子类指针由工厂类得到

# 继承和面向对象设计

### 条款35

B公有继承A:代表B`是一个`A

B`是一个`A:B的行为(成员函数,接口)是A行为的超集,A能做的B都能,且行为和A保持概念上的一致性

所以,生物学上企鹅是鸟,但是从会飞(行为)这个角度,企鹅在程序里不能按鸟算

正方形在数学概念上是矩形,但是程序中不是,因为从行为上,改变正方形的长,一定改变它的宽,而矩形不是这样,带来了概念上的不一致

```
个人理解:这里是因为现实概念是声明式的,静态的,程序是命令式的,动态的,"改变"在现实概念里是不存在的

希望现实中也有人总结一套动态一致性概念,这样写程序就能有依据了
```

### 条款36
纯虚函数,虚函数和非虚函数在继承中的意义

* 纯虚函数:继承接口而不继承实现
* 虚函数:继承接口,但有默认实现以减少代码冗余
    ```
    对于函数a,可以写一个protected的默认实现defaultA,而把a声明为纯虚,这样可以防止有人需要改写虚函数却忘记了
    ```
* 非虚函数:继承接口和实现,且不允许改变

### 条款37
不要在子类覆盖父类的非虚函数

参考上面非虚函数的意义,了解到如果子类需要改变行为,应当把这个函数声明为虚函数,否则当使用父类指针和子类指针引用同一个对象,调用同一个函数行为却不一致,令人困惑

### 条款38
不要在子类重写父类函数的缺省参数值

首先根据条款37,不应该覆盖父类的非虚函数

而对于虚函数,因为缺省参数值是静态绑定的,即使用父类指针调用虚函数,也不会传子类中定义的缺省参数值,因为虚表中只存储了函数指针,没存参数值(为了效率)

### 条款39
不要对指针进行向下转型(父类指针->子类指针)

因为这么做无非是想对父类指针执行子类行为,那么这种情况意味着,要么这个地方拿到手的根本就不该是个父类指针,而应该是子类指针,要么这个行为应该放在父类而不是子类

当然,如果无法修改父类,也无法修改当前位置拿到的指针类型,那就只能硬着头皮转换了,但是最好用dynamic_cast,如果转换失败,会返回空指针,也不至于让错误的程序继续下去而我们一无所知

### 条款40
类之间的包含(composition)关系
```c++
class A{
    B b;
}
```

需要和继承关系做出区分,A需要使用B来实现其功能,却又不需要和B的行为保持一致时,采用这种方式,但这会使得A在编译上和B产生绑定,解决方案见条款34


### 条款41

同样都是对于不同的类型,采用不同的行为

什么时候用模板,什么时候用虚函数?

如果这个行为的过程不会因为类型T的变化而变化(函数体除了T都一样),就用模板(比如vector<T>的`push_back`行为之于T),否则用虚函数(比如animal的`叫`行为之于之于cat,dog)

### 条款42
private继承的意义

private继承的意义和composition是一样的,A private继承 B等同于A把B做一个private数据成员,所以尽量使用composition,更灵活,少用private继承.

private继承是有用的,当基类不应该被构造和使用的时候,把它的构造函数声明为protected,然后把应该被使用的实现private继承基类

书中例子简化

```c++
class StackNode{
    void* data;
    StackNode* next;
};

class GenericStack{
    //这个类不应该被使用,因为可以push进多种类型的指针
    protected:
    GenericStack(){...};
    StackNode* top;
    void push(void* data){...}
    ...
};

template<class T> class Stack:private GenericStack{
    //这个类应当被使用
    public:
    void push(T* data){GenericStack::push(data);}
    ...
}
```

### 条款43

多继承:内容略,很复杂,尽量别用,学java那一套,要搞多继承就用只包含纯虚函数,不含任何数据的类

### 条款44

写类之间的关系时先看看它们之间是`是一个`,`有一个`,或者什么的关系,看看函数是否应当被继承,应当被重写,然后再设计和实现

也就是总结上述条款

# 杂项

### 条款45
c++自动为类生成:一个拷贝构造函数(向下调用所有成员的拷贝构造),
缺省构造函数(啥也不干),
，一个赋值运算符(向下调用所有成员的赋值)
，一个析构函数(啥也不干)
，const和非const的取址运算符(return this)。

c++的引用无法重定向,所以无法自动生成赋值

### 条款46

尽可能利用编译时检查来保证对象的正确性,而不要推到运行时

### 条款47

静态对象在编译单元间初始化顺序不确定,所以采用单例模式来保证用到时一定初始化了

### 条款48
用好stl
### 条款49
C++的理念: 和C兼容,高性能,兼容传统编译器,链接器,强大的解决问题的能力

### 条款50
深入理解c++,读标准....我读不来啊