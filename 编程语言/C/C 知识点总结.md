## C 知识点总结

### 1. 关键字

#### auto

* auto 是 C 语言中局部变量的默认属性，局部变量在栈上分配空间
* 编译器默认所有的局部变量都是 auto

#### static

* static 指明变量的“静态”属性
* static 同时具有“作用域限定符”的意义
* static 局部变量只被初始化一次，下一次依据上一次结果值
* static 全局变量只被初始化一次，防止在其他文件中被引用
* static 修饰的函数作用域只是在声明的文件中，内存中只有一份，普通函数在每一个被调用中维持一份拷贝

#### register

* register 声明的变量为局部变量
* register 指明将变量存储在 CPU 寄存器中，不能用 & 运算符获取 register 变量的地址
* register 只是请求寄存器变量，但不一定请求成功

#### void

* void 修饰函数返回值和参数
* void* 指针作为左值，用于接收任意类型的指针
* void* 指针作为右值，赋给其它指针时需要强制类型转换

#### extern

* extern 用于声明外部定义的变量和函数
* extern 用于告诉编译器用 C 方式编译
* C++ 支持函数重载，所以在编译的时候，编译器会为每个同名函数重新命名，加上 extern "C" 就是为了防止函数重新命名

#### sizeof

* sizeof 是编译器的内置指示符，不是函数
* sizeof 用来计算相应实体所占的内存大小
* sizeof 的值在编译期就已经确定

#### const

* 在 C 语言中，const 修饰的变量是只读的，但本质还是变量
* const 修饰的变量会在内存中占用空间(通过取地址操作符，得 const 修饰的变量的地址，改变它在内存的值)
* 本质上 const 只对编译器有用，在运行时无用
* 在 C 语言中，const 修饰的数组是只读的
* const 修饰的数组空间不可被改变
* const 修饰函数参数表示在函数体内不希望改变参数的值
* const 修饰函数返回值表示返回值不可改变

#### volatile

* volatile 可理解为“编译器警告指示符”
* volatile 用于告诉编译器必须每次去内存中取变量值
* volatile 主要修饰可能被多个线程访问的变量
* volatile 也可以修饰可能被未知因素更改的变量

#### union 和 struct

* struct 中的每个域在内存中都独立分配空间
* union 只分配最大域的空间，所有域都共享这个空间
* union 的使用受系统大小端影响，可以用 union 来判断系统的大小端

#### enum

* enum 是一种自定义类型，真正的常量
* enum 默认常量在前一个值的基础上依次加 1
* enum 类型的变量只能取定义的离散值

#### typedef

* typedef 用于给一个已经存在的数据类型重命名
* typedef 并没有产生新的类型
* typedef 重定义的类型不能进行 signed 和 unsigned 扩展

### 2. 符号

#### 接续符 `\`

* 实际上是转义符，接续符适合在定义宏代码块时使用，把换行转义掉

#### 单引号和双引号

* 单引号表示字符常量，如 'a'，在内存中占 1 个字节
* 双引号表示字符串常量，如 "a"，在内存中占 2 个字节

#### 逻辑运算符

* `||` 从左到右计算，遇到真的条件就停止计算，整个表达式为真
* `&&` 从左到右计算，遇到假的条件就停止计算，整个表达式为假
* `!` 取非

#### 三目运算符

* (a ? b : c) a 为真，返回 b 的值；否则返回 c 的值

#### 位运算符

* 左移运算符 << 规则是高位丢弃，低位补 0
* 右移运算符 >> 规则是高位补符号位，低位丢弃
* 左移 n 位相当于乘以 2 的 n 次方
* 右移 n 位相当于除以 2 的 n 次方

#### 优先级

* `.` 优先级高于 `*`
* `[]`优先级高于 `*`
* `函数()`优先级高于 `*`
* `==` 和 `!=` 高于赋值符
* `==` 和 `!=` 高于位操作

#### 自动（隐式）类型转换

* 算术运算式中，低类型转换为高类型
* 有符号类型转换为无符号类型

### 3. 编译预处理

#### 编译过程

* 预编译：`gcc -E file.c -o file.i`，处理所有的注释，以空格代替；处理 #include，展开被包含的文件；将所有
的 #define 删除，并且展开所有的宏定义等
* 编译：`gcc -S file.i -o file.s`，对预处理文件进行一系列词法分析，语法分析和语义分析
* 汇编：`gcc -c file.s -o file.o`，汇编器将汇编代码转变为机器可以执行的指令
* 链接：静态链接(.a)和动态链接(.so)，使用静态链接，可执行文件比较大；使用动态链接，效率低些

#### 宏定义和使用

* 宏表达式在预编译期被处理，编译期不知道宏表达式的存在
* 宏表达式没有任何的调用开销
* 宏表达式中不能出现递归定义

#### 条件编译

* 条件编译时预编译指示命令，用于控制是否编译某段代码
* 条件编译可以避免重复包含同一个文件

#### #error、#warning 和 #line

* #error 用于生成一个编译错误消息，并停止编译
* #warning 用于生成一个编译警告，但不停止编译
* #line 用于强制指定新的行号和编译文件名，并对源程序的代码重新编号

#### #pragma

* #pragma 是编译器指示字，用于指示编译器完成一些特定的动作
* #pragma pack() 内存对齐，按照一定的规则排列

#### `#` 和 `##`

* `#` 运算符用于在预编译期将宏参数转换为字符串
* `##` 运算符用于在预编译期连接两个符号，连接作用

### 4. 指针与数组

#### 指针含义

* 指针在本质上也是一个变量
* 指针需要占用一定的内存空间
* 指针用于保存内存地址的值
* 不同类型的指针占用的空间大小在不同的机器上是不一样的
* int* p; // 指针的类型为 int*，指针指向的类型为 int

#### 数组含义

* 数组是相同类型的变量的有序集合
* 数组在一片连续的内存空间中存储元素
* 数组元素的个数：int a[]sizeof(a)/sizeof(*a)

#### 数组地址 &a 和数组名 a 的区别

* 数组名代表数组首元素的地址
* 数组的地址需要取地址符 & 才能得到
* 数组名 a 代表数组首元素的地址，数组的地址 &a 指向整个数组地址
* a + 1 => (unsigned int)a + sizeof(*a)
* &a + 1 => (unsigned int)(&a) + sizeof(* &a)

#### 数组和指针的分析

* 数组的空间大小为 sizeof(array_type) * array_size
* 指针之间只能做减法运算，且必须参与运算的指针类型必须相同
* *(a+i) = a[i]

#### 字符串

* C 语言中的字符串是以 `\0` 结束的字符数组
* C 语言中的字符串可以分配在栈空间、堆空间、只读存储区上
* strcpy、strncpy 的实现

#### 指针数组与数组指针

* 通过 typedef 为数组类型重命名，typedef type(name)[size]
* 数组指针用于指向一个数组
* 数组指针：`type(*pointer)[n]`
* 指针数组是一个普通的数组，每个元素为一个指针
* 指针数组的定义：`type* pArray[n]`

#### main 函数的参数

* argc 是命令行参数的个数，argv 是命令行参数数组，env 是环境变量数组

#### 多维数组和多维指针

* 指针在本质上也是变量，指针可以用来保存指针变量的地址值
* 二维数组在内存中以一维的方式布局
* int a[5][5] => a 的类型为 `int(*)[5]`

#### 函数与指针

* 函数的类型由返回值，参数类型和参数个数共同决定
* 使用 typedef 为函数类型重命名：typedef type name(parameter list)
* 函数指针用于指向一个函数
* 定义函数指针：`type (*pointer)(parameter list)`
* 回调函数是利用函数指针实现的一种调用机制
* 回调机制将调用者和被调函数分开，两者互不依赖

### 5. 内存管理

#### 动态内存分配

* malloc 和 free 用于执行动态内存分配和释放
* malloc 从系统中申请固定字节大小的内存
* calloc 以类型大小为单位，申请内存并且初始化为 0
* realloc 用于重置内存的大小

#### 栈

* 栈在程序中用于维护函数调用上下文，没有栈就没有函数，没有局部变量
* 栈保存了一个函数调用所需的维护信息：函数参数，函数返回地址，局部变量，函数调用上下文

#### 堆

* 堆空间需要通过申请才能获得
* 栈的数据在函数返回后就会释放，无法传递到函数外部，如局部数组
* 系统对堆空间的管理方式：空间链表法，位图法，对象池法

#### 静态存储区

* 静态存储区用于保存全局变量和静态变量
* 在程序的编译期间静态存储区的大小就已经确定
* 静态存储区的信息最终保存在可执行程序中

#### 程序的内存布局

* .text 段存放的是程序中的可执行代码
* .data 段保存的是哪些已经初始化的全局变量和静态变量
* .bss 段存放的是未初始化的全局变量和静态变量
* 堆：动态空间
* 栈：局部变量所占空间

静态存储区通常指程序中的 .bss 和 .data 段。

只读区通常指程序中的 .rodata 段。

#### 野指针

* 野指针不是 NULL 指针，是不可用内存的指针
* 造成野指针：内存分配成功，但并未初始化；内存越界；内存泄露；多次指针释放；使用已释放的指针

free 指针之后必须立即赋值为 NULL。

### 6. 函数

#### 函数含义

* 函数是 C 语言的核心；指针是 C 语言的难点
* 函数参数在本质上与局部变量相同，都是在栈上分配空间
* C 语言会默认没有类型的函数参数为 int

#### 可变参数列表与宏分析

* va_list 变量与 va_start, va_end 和 va_arg 配合使用能够访问参数值
* 可变参数必须顺序访问

#### 函数调用行为

* 活动记录是函数调用时用于记录一系列相关信息的记录
* 函数参数的计算次序是依赖编译器实现的，函数参数的入栈次序

#### 函数递归

* 递归的本质是函数内部在适当的时候调用自身
* 递归函数在需要编写的时候定义函数的出口，否则栈会溢出

 
